import { Controller, Get, Query } from '@nestjs/common';\n\n/**\n * ğŸ“Š ì„±ëŠ¥ ëŒ€ì‹œë³´ë“œ ì»¨íŠ¸ë¡¤ëŸ¬\n * \n * ê¸°ëŠ¥:\n * - ì‹¤ì‹œê°„ ì„±ëŠ¥ ë©”íŠ¸ë¦­ ì¡°íšŒ\n * - ëŠë¦° ì—”ë“œí¬ì¸íŠ¸ ë¶„ì„\n * - ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§\n * - ì„±ëŠ¥ ê²½ê³  ë° ì•Œë¦¼ ê´€ë¦¬\n */\n@Controller('admin/performance')\nexport class PerformanceDashboardController {\n  \n  /**\n   * ğŸ“ˆ ì „ì²´ ì„±ëŠ¥ ë©”íŠ¸ë¦­ ì¡°íšŒ\n   */\n  @Get('metrics')\n  async getPerformanceMetrics() {\n    const memoryUsage = process.memoryUsage();\n    const uptime = process.uptime();\n    const cpuUsage = process.cpuUsage();\n    \n    return {\n      message: 'ì„±ëŠ¥ ë©”íŠ¸ë¦­ ì¡°íšŒ ì„±ê³µ',\n      data: {\n        requests: {\n          total: 1000, // ì˜ˆì‹œ ë°ì´í„°\n          slow: 25,\n          slowRate: 2.5,\n        },\n        responseTime: {\n          average: 35.5,\n          max: 850,\n        },\n        system: {\n          uptime: Math.round(uptime),\n          memory: {\n            used: Math.round(memoryUsage.heapUsed / 1024 / 1024),\n            total: Math.round(memoryUsage.heapTotal / 1024 / 1024),\n            rss: Math.round(memoryUsage.rss / 1024 / 1024),\n            external: Math.round(memoryUsage.external / 1024 / 1024),\n          },\n          cpu: {\n            user: cpuUsage.user,\n            system: cpuUsage.system,\n          },\n        },\n        timestamp: new Date().toISOString(),\n      },\n    };\n  }\n\n  /**\n   * ğŸŒ ëŠë¦° ì—”ë“œí¬ì¸íŠ¸ ë¶„ì„\n   */\n  @Get('slow-endpoints')\n  async getSlowEndpoints(\n    @Query('limit') limit: string = '10',\n    @Query('threshold') threshold: string = '1000'\n  ) {\n    // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë°ì´í„°ë² ì´ìŠ¤ë‚˜ ë¡œê·¸ ì‹œìŠ¤í…œì—ì„œ ì¡°íšŒ\n    const slowEndpoints = [\n      {\n        endpoint: 'GET /api/v1/courses',\n        averageResponseTime: 1250,\n        maxResponseTime: 2100,\n        requestCount: 145,\n        slowRequestCount: 23,\n        slowRate: 15.86,\n        lastSlowRequest: new Date(Date.now() - 30000).toISOString(),\n      },\n      {\n        endpoint: 'POST /api/v1/user-course-progress',\n        averageResponseTime: 1150,\n        maxResponseTime: 1890,\n        requestCount: 89,\n        slowRequestCount: 12,\n        slowRate: 13.48,\n        lastSlowRequest: new Date(Date.now() - 120000).toISOString(),\n      },\n    ];\n\n    return {\n      message: 'ëŠë¦° ì—”ë“œí¬ì¸íŠ¸ ë¶„ì„ ì™„ë£Œ',\n      data: {\n        threshold: parseInt(threshold),\n        endpoints: slowEndpoints.slice(0, parseInt(limit)),\n        summary: {\n          totalSlowEndpoints: slowEndpoints.length,\n          averageSlowRate: slowEndpoints.reduce((acc, ep) => acc + ep.slowRate, 0) / slowEndpoints.length,\n        },\n      },\n    };\n  }\n\n  /**\n   * ğŸ’¾ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¶”ì´\n   */\n  @Get('memory-usage')\n  async getMemoryUsage(@Query('period') period: string = '1h') {\n    const currentMemory = process.memoryUsage();\n    \n    // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì‹œê³„ì—´ ë°ì´í„° ì¡°íšŒ\n    const memoryHistory = Array.from({ length: 12 }, (_, i) => {\n      const timestamp = new Date(Date.now() - (11 - i) * 5 * 60 * 1000);\n      const variance = Math.random() * 0.2 - 0.1; // Â±10% ë³€ë™\n      \n      return {\n        timestamp: timestamp.toISOString(),\n        heapUsed: Math.round((currentMemory.heapUsed * (1 + variance)) / 1024 / 1024),\n        heapTotal: Math.round((currentMemory.heapTotal * (1 + variance * 0.5)) / 1024 / 1024),\n        rss: Math.round((currentMemory.rss * (1 + variance * 0.3)) / 1024 / 1024),\n        external: Math.round((currentMemory.external * (1 + variance)) / 1024 / 1024),\n      };\n    });\n\n    return {\n      message: 'ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¡°íšŒ ì„±ê³µ',\n      data: {\n        period,\n        current: {\n          heapUsed: Math.round(currentMemory.heapUsed / 1024 / 1024),\n          heapTotal: Math.round(currentMemory.heapTotal / 1024 / 1024),\n          rss: Math.round(currentMemory.rss / 1024 / 1024),\n          external: Math.round(currentMemory.external / 1024 / 1024),\n        },\n        history: memoryHistory,\n        trends: {\n          heapGrowth: this.calculateTrend(memoryHistory.map(h => h.heapUsed)),\n          memoryLeaks: memoryHistory.filter((_, i, arr) => \n            i > 0 && arr[i].heapUsed > arr[i-1].heapUsed * 1.1\n          ).length,\n        },\n      },\n    };\n  }\n\n  /**\n   * ğŸ“Š ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬\n   */\n  @Get('health')\n  async getSystemHealth() {\n    const memory = process.memoryUsage();\n    const uptime = process.uptime();\n    \n    // í—¬ìŠ¤ ì ìˆ˜ ê³„ì‚° (0-100)\n    const memoryScore = Math.max(0, 100 - (memory.heapUsed / memory.heapTotal) * 100);\n    const responseTimeScore = 85; // ì˜ˆì‹œ ê°’\n    const errorRateScore = 92; // ì˜ˆì‹œ ê°’\n    \n    const overallScore = Math.round((memoryScore + responseTimeScore + errorRateScore) / 3);\n    \n    let healthStatus = 'healthy';\n    if (overallScore < 60) healthStatus = 'critical';\n    else if (overallScore < 80) healthStatus = 'warning';\n    \n    return {\n      message: 'ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬ ì™„ë£Œ',\n      data: {\n        status: healthStatus,\n        score: overallScore,\n        details: {\n          memory: {\n            score: Math.round(memoryScore),\n            usage: Math.round((memory.heapUsed / memory.heapTotal) * 100),\n            status: memoryScore > 70 ? 'good' : memoryScore > 50 ? 'warning' : 'critical',\n          },\n          performance: {\n            score: responseTimeScore,\n            averageResponseTime: 35.5,\n            status: 'good',\n          },\n          reliability: {\n            score: errorRateScore,\n            slowRequestRate: 2.5,\n            status: 'good',\n          },\n        },\n        uptime: Math.round(uptime),\n        timestamp: new Date().toISOString(),\n      },\n    };\n  }\n\n  /**\n   * ğŸ“ˆ íŠ¸ë Œë“œ ê³„ì‚° ìœ í‹¸ë¦¬í‹°\n   */\n  private calculateTrend(values: number[]): string {\n    if (values.length < 2) return 'stable';\n    \n    const first = values[0];\n    const last = values[values.length - 1];\n    const change = ((last - first) / first) * 100;\n    \n    if (change > 10) return 'increasing';\n    if (change < -10) return 'decreasing';\n    return 'stable';\n  }\n}